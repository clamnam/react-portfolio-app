{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nfunction ignoreFunction() {}\nfunction createReturningFunction(value) {\n  return function () {\n    return value;\n  };\n}\nfunction Parser(states) {\n  this.states = this.compileStates(states);\n}\nParser.prototype.compileStates = function (states) {\n  var result = {};\n  Object.keys(states).forEach(function (name) {\n    result[name] = this.compileState(states[name], states);\n  }, this);\n  return result;\n};\nParser.prototype.compileState = function (state, states) {\n  var regExps = [];\n  function iterator(str, value) {\n    regExps.push({\n      groups: Parser.getGroupCount(str),\n      regExp: str,\n      value: value\n    });\n  }\n  function processState(statePart) {\n    if (Array.isArray(statePart)) {\n      statePart.forEach(processState);\n    } else if (typeof statePart === \"object\") {\n      Object.keys(statePart).forEach(function (key) {\n        iterator(key, statePart[key]);\n      });\n    } else if (typeof statePart === \"string\") {\n      processState(states[statePart]);\n    } else {\n      throw new Error(\"Unexpected 'state' format\");\n    }\n  }\n  processState(state);\n  var total = regExps.map(function (r) {\n    return \"(\" + r.regExp + \")\";\n  }).join(\"|\");\n  var actions = [];\n  var pos = 1;\n  regExps.forEach(function (r) {\n    var fn;\n    if (typeof r.value === \"function\") {\n      fn = r.value;\n    } else if (typeof r.value === \"string\") {\n      fn = createReturningFunction(r.value);\n    } else {\n      fn = ignoreFunction;\n    }\n    actions.push({\n      name: r.regExp,\n      fn: fn,\n      pos: pos,\n      pos2: pos + r.groups + 1\n    });\n    pos += r.groups + 1;\n  });\n  return {\n    regExp: new RegExp(total, \"g\"),\n    actions: actions\n  };\n};\nParser.getGroupCount = function (regExpStr) {\n  return new RegExp(\"(\" + regExpStr + \")|^$\").exec(\"\").length - 2;\n};\nParser.prototype.parse = function (initialState, string, context) {\n  context = context || {};\n  var currentState = initialState;\n  var currentIndex = 0;\n  for (;;) {\n    var state = this.states[currentState];\n    var regExp = state.regExp;\n    regExp.lastIndex = currentIndex;\n    var match = regExp.exec(string);\n    if (!match) return context;\n    var actions = state.actions;\n    currentIndex = state.regExp.lastIndex;\n    for (var i = 0; i < actions.length; i++) {\n      var action = actions[i];\n      if (match[action.pos]) {\n        var ret = action.fn.apply(context, Array.prototype.slice.call(match, action.pos, action.pos2).concat([state.regExp.lastIndex - match[0].length, match[0].length]));\n        if (ret) {\n          if (!(ret in this.states)) throw new Error(\"State '\" + ret + \"' doesn't exist\");\n          currentState = ret;\n        }\n        break;\n      }\n    }\n  }\n};\nmodule.exports = Parser;","map":{"version":3,"names":["ignoreFunction","createReturningFunction","value","Parser","states","compileStates","prototype","result","Object","keys","forEach","name","compileState","state","regExps","iterator","str","push","groups","getGroupCount","regExp","processState","statePart","Array","isArray","key","Error","total","map","r","join","actions","pos","fn","pos2","RegExp","regExpStr","exec","length","parse","initialState","string","context","currentState","currentIndex","lastIndex","match","i","action","ret","apply","slice","call","concat","module","exports"],"sources":["/Users/jackmoloneyobrien/Desktop/College/Front-End/portfolio-example-2/node_modules/fastparse/lib/Parser.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nfunction ignoreFunction() {}\n\nfunction createReturningFunction(value) {\n\treturn function() {\n\t\treturn value;\n\t};\n}\n\nfunction Parser(states) {\n\tthis.states = this.compileStates(states);\n}\n\nParser.prototype.compileStates = function(states) {\n\tvar result = {};\n\tObject.keys(states).forEach(function(name) {\n\t\tresult[name] = this.compileState(states[name], states);\n\t}, this);\n\treturn result;\n};\n\nParser.prototype.compileState = function(state, states) {\n\tvar regExps = [];\n\tfunction iterator(str, value) {\n\t\tregExps.push({\n\t\t\tgroups: Parser.getGroupCount(str),\n\t\t\tregExp: str,\n\t\t\tvalue: value\n\t\t});\n\t}\n\tfunction processState(statePart) {\n\t\tif(Array.isArray(statePart)) {\n\t\t\tstatePart.forEach(processState);\n\t\t} else if(typeof statePart === \"object\") {\n\t\t\tObject.keys(statePart).forEach(function(key) {\n\t\t\t\titerator(key, statePart[key]);\n\t\t\t});\n\t\t} else if(typeof statePart === \"string\") {\n\t\t\tprocessState(states[statePart]);\n\t\t} else {\n\t\t\tthrow new Error(\"Unexpected 'state' format\");\n\t\t}\n\t}\n\tprocessState(state);\n\tvar total = regExps.map(function(r) {\n\t\treturn \"(\" + r.regExp + \")\";\n\t}).join(\"|\");\n\tvar actions = [];\n\tvar pos = 1;\n\tregExps.forEach(function(r) {\n\t\tvar fn;\n\t\tif(typeof r.value === \"function\") {\n\t\t\tfn = r.value;\n\t\t} else if(typeof r.value === \"string\") {\n\t\t\tfn = createReturningFunction(r.value);\n\t\t} else {\n\t\t\tfn = ignoreFunction;\n\t\t}\n\t\tactions.push({\n\t\t\tname: r.regExp,\n\t\t\tfn: fn,\n\t\t\tpos: pos,\n\t\t\tpos2: pos + r.groups + 1\n\t\t});\n\t\tpos += r.groups + 1;\n\t});\n\treturn {\n\t\tregExp: new RegExp(total, \"g\"),\n\t\tactions: actions\n\t};\n};\n\nParser.getGroupCount = function(regExpStr) {\n\treturn new RegExp(\"(\" + regExpStr + \")|^$\").exec(\"\").length - 2;\n};\n\nParser.prototype.parse = function(initialState, string, context) {\n\tcontext = context || {};\n\tvar currentState = initialState;\n\tvar currentIndex = 0;\n\tfor(;;) {\n\t\tvar state = this.states[currentState];\n\t\tvar regExp = state.regExp;\n\t\tregExp.lastIndex = currentIndex;\n\t\tvar match = regExp.exec(string);\n\t\tif(!match) return context;\n\t\tvar actions = state.actions;\n\t\tcurrentIndex = state.regExp.lastIndex;\n\t\tfor(var i = 0; i < actions.length; i++) {\n\t\t\tvar action = actions[i];\n\t\t\tif(match[action.pos]) {\n\t\t\t\tvar ret = action.fn.apply(context, Array.prototype.slice.call(match, action.pos, action.pos2).concat([state.regExp.lastIndex - match[0].length, match[0].length]));\n\t\t\t\tif(ret) {\n\t\t\t\t\tif(!(ret in this.states))\n\t\t\t\t\t\tthrow new Error(\"State '\" + ret + \"' doesn't exist\");\n\t\t\t\t\tcurrentState = ret;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}